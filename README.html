
<!DOCTYPE html><html><head><title>R: depth_pairs_findr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>depth_pairs_findr</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>depth_pairs_findr</h2>

<h3>Description</h3>

<p>Takes the pair vector as an input and associate to each pair a level of depth, see examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth_pairs_findr(inpt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt">inpt</code></td>
<td>
<p>is the pair vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(depth_pairs_findr(c(1, 1, 2, 3, 3, 4, 4, 2, 5, 6, 7, 7, 6, 5)))

 [1] 1 1 1 2 2 2 2 1 1 2 3 3 2 1

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: inner_all</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>inner_all</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>inner_all</h2>

<h3>Description</h3>

<p>Allow to apply inner join on n dataframes, datatables, tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_all(..., keep_val = FALSE, id_v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="...">...</code></td>
<td>
<p>are all the dataframes etc</p>
</td></tr>
<tr><td><code id="keep_val">keep_val</code></td>
<td>
<p>is if you want to keep the id column</p>
</td></tr>
<tr><td><code id="id_v">id_v</code></td>
<td>
<p>is the common id of all the dataframes etc</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(
        "id1"=c(1:5),
        "var1"=c("oui", "oui", "oui", "non", "non")
)

datf2 &lt;- data.frame(
        "id1"=c(1, 2, 3, 7, 9),
        "var1"=c("oui2", "oui2", "oui2", "non2", "non2")
)

print(inner_all(datf1, datf2, keep_val=FALSE, id_v="id1"))

id1 var1.x var1.y
1   1    oui   oui2
2   2    oui   oui2
3   3    oui   oui2

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: intersect_all</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>intersect_all</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>intersect_all</h2>

<h3>Description</h3>

<p>Allows to calculate the intersection between n vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_all(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="...">...</code></td>
<td>
<p>is all the vector you want to calculate the intersection from</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(intersect_all(c(1:5), c(1, 2, 3, 6), c(1:4)))

[1] 1 2 3

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: join_n_lvl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>join_n_lvl</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>join_n_lvl</h2>

<h3>Description</h3>

<p>Allow to see the progress of the multi-level joins of the different variables modalities. Here, multi-level joins is a type of join that usually needs a concatenation of two or more variables to make a key. But here, there is no need to proceed to a concatenation. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_n_lvl(frst_datf, scd_datf, join_type = c(), lst_pair = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frst_datf">frst_datf</code></td>
<td>
<p>is the first data.frame (table)</p>
</td></tr>
<tr><td><code id="scd_datf">scd_datf</code></td>
<td>
<p>is the second data.frame (table)</p>
</td></tr>
<tr><td><code id="join_type">join_type</code></td>
<td>
<p>is a vector containing all the join type (&quot;left&quot;, &quot;inner&quot;, &quot;right&quot;) for each variable</p>
</td></tr>
<tr><td><code id="lst_pair">lst_pair</code></td>
<td>
<p>is a lis of vectors. The vectors refers to a multi-level join. Each vector should have a length of 1. Each vector should have a name. Its name refers to the column name of multi-level variable and its value refers to the column name of the join variable.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf3 &lt;- data.frame("vil"=c("one", "one", "one", "two", "two", "two"),
                     "charac"=c(1, 2, 2, 1, 2, 2),
                     "rev"=c(1250, 1430, 970, 1630, 2231, 1875),
                     "vil2" = c("one", "one", "one", "two", "two", "two"),
                     "idl2" = c(1:6))
datf4 &lt;- data.frame("vil"=c("one", "one", "one", "two", "two", "three"),
                    "charac"=c(1, 2, 2, 1, 1, 2),
                     "rev"=c(1.250, 1430, 970, 1630, 593, 456),
                     "vil2" = c("one", "one", "one", "two", "two", "two"),
                     "idl2" = c(2, 3, 1, 5, 5, 5))

print(join_n_lvl(frst_datf=datf3, scd_datf=datf4, lst_pair=list(c("charac" = "vil"), c("vil2" = "idl2")), 
                 join_type=c("inner", "left")))

[1] "pair: charac vil"
|  |   0%
1 
|= |  50%
2 
|==| 100%
[1] "pair: vil2 idl2"
|  |   0%
one 
|= |  50%
two 
|==| 100%

  main_id.x vil.x charac.x rev.x vil2.x idl2.x main_id.y vil.y charac.y rev.y
1  1oneone1   one        1  1250    one      1      &lt;NA&gt;  &lt;NA&gt;       NA    NA
2  2oneone2   one        2  1430    one      2      &lt;NA&gt;  &lt;NA&gt;       NA    NA
3  2oneone3   one        2   970    one      3  2oneone3   one        2  1430
4  1twotwo4   two        1  1630    two      4      &lt;NA&gt;  &lt;NA&gt;       NA    NA
  vil2.y idl2.y
1   &lt;NA&gt;     NA
2   &lt;NA&gt;     NA
3    one      3
4   &lt;NA&gt;     NA

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: left_all</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>left_all</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>left_all</h2>

<h3>Description</h3>

<p>Allow to apply left join on n dataframes, datatables, tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left_all(..., keep_val = FALSE, id_v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="...">...</code></td>
<td>
<p>are all the dataframes etc</p>
</td></tr>
<tr><td><code id="keep_val">keep_val</code></td>
<td>
<p>is if you want to keep the id column</p>
</td></tr>
<tr><td><code id="id_v">id_v</code></td>
<td>
<p>is the common id of all the dataframes etc</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
datf1 &lt;- data.frame(
        "id1"=c(1:5),
        "var1"=c("oui", "oui", "oui", "non", "non")
)

datf2 &lt;- data.frame(
        "id1"=c(1, 2, 3, 7, 9),
        "var1"=c("oui2", "oui2", "oui2", "non2", "non2")
)

print(left_all(datf1, datf2, datf2, datf2, keep_val=FALSE, id_v="id1"))

  id1 var1.x var1.y var1.x.x var1.y.y
1   1    oui   oui2     oui2     oui2
2   2    oui   oui2     oui2     oui2
3   3    oui   oui2     oui2     oui2
4   4    non   &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;
5   5    non   &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;#'
print(left_all(datf1, datf2, datf2, keep_val=FALSE, id_v="id1"))

  id1 var1.x var1.y var1
1   1    oui   oui2 oui2
2   2    oui   oui2 oui2
3   3    oui   oui2 oui2
4   4    non   &lt;NA&gt; &lt;NA&gt;
5   5    non   &lt;NA&gt; &lt;NA&gt;

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: pairs_findr_merger</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>pairs_findr_merger</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>pairs_findr_merger</h2>

<h3>Description</h3>

<p>Takes two different outputs from pairs_findr and merge them. Can be usefull when the pairs consists in different patterns, for example one output from the pairs_findr function with ptrn1 = &quot;(&quot; and ptrn2 = &quot;)&quot;, and a second output from the pairs_findr function with ptrn1 = &quot;&quot; and ptrn2 = &quot;&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_findr_merger(lst1 = list(), lst2 = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lst1">lst1</code></td>
<td>
<p>is the first ouput from pairs findr function</p>
</td></tr>
<tr><td><code id="lst2">lst2</code></td>
<td>
<p>is the second ouput from pairs findr function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 7, 8, 9)), 
                         lst2=list(c(1, 1), c(1, 2))))

[[1]]
[1] 1 1 2 3 4 4 3 2

[[2]]
[1] 1 2 3 4 5 7 8 9

print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 7, 8, 9)), 
                         lst2=list(c(1, 1), c(1, 11))))

[[1]]
[1] 1 2 3 4 4 3 2 1

[[2]]
[1]  1  3  4  5  7  8  9 11

print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 8, 10, 11)), 
                         lst2=list(c(4, 4), c(6, 7))))

[[1]]
[1] 1 2 3 4 4 3 2 1

[[2]]
[1]  3  4  5  6  7  8 10 11

print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 7, 10, 11)), 
                         lst2=list(c(4, 4), c(8, 9))))

[[1]]
[1] 1 2 3 3 4 4 2 1

[[2]]
[1]  3  4  5  7  8  9 10 11

print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 7, 10, 11)), 
                         lst2=list(c(4, 4), c(18, 19))))

[[1]]
[1] 1 2 3 3 2 1 4 4

[[2]]
[1]  3  4  5  7 10 11 18 19

print(pairs_findr_merger(lst1 = list(c(1, 1, 2, 2, 3, 3), c(1, 25, 26, 32, 33, 38)), 
                        lst2 = list(c(1, 1, 2, 2, 3, 3), c(7, 11, 13, 17, 19, 24))))

[[1]]
 [1] 1 2 2 3 3 4 4 1 5 5 6 6

[[2]]
 [1]  1  7 11 13 17 19 24 25 26 32 33 38

print(pairs_findr_merger(lst1 = list(c(1, 1, 2, 2, 3, 3), c(2, 7, 9, 10, 11, 15)), 
                         lst2 = list(c(3, 2, 1, 1, 2, 3, 4, 4), c(1, 17, 18, 22, 23, 29, 35, 40))))

[[1]]
 [1] 6 5 1 1 2 2 3 3 4 4 5 6 7 7

[[2]]
 [1]  1  2  7  9 10 11 15 17 18 22 23 29 35 40

print(pairs_findr_merger(lst1 = list(c(1, 1), c(22, 23)), 
                         lst2 = list(c(1, 1, 2, 2), c(3, 21, 27, 32))))

[[1]]
[1] 1 1 2 2 3 3

[[2]]
[1]  3 21 22 23 27 32

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: pairs_findr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>pairs_findr</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>pairs_findr</h2>

<h3>Description</h3>

<p>Takes a character as input and detect the pairs of pattern, like the parenthesis pais if the pattern is &quot;(&quot; and then &quot;)&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_findr(inpt, ptrn1 = "(", ptrn2 = ")")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt">inpt</code></td>
<td>
<p>is the input character</p>
</td></tr>
<tr><td><code id="ptrn1">ptrn1</code></td>
<td>
<p>is the first pattern ecountered in the pair</p>
</td></tr>
<tr><td><code id="ptrn2">ptrn2</code></td>
<td>
<p>is the second pattern in the pair</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(pairs_findr(inpt="ze+(yu*45/(jk+zz)*(o()p))-(re*(rt+qs)-fg)"))

[[1]]
 [1] 4 1 1 3 2 2 3 4 6 5 5 6

[[2]]
 [1]  4 11 17 19 21 22 24 25 27 31 37 41

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: pairs_insertr2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>pairs_insertr2</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>pairs_insertr2</h2>

<h3>Description</h3>

<p>Takes a character representing an arbitrary condition (like ReGeX for example) or an information (to a parser for example), vectors containing all the pair of pattern that potentially surrounds condition (flagged_pair_v and corr_v), and a vector containing all the conjuntion character, as input and returns the character with all or some of the condition surrounded by the pair characters. See examples. All the pair characters are inserted according to the closest pair they found priotizing those found next to the condition and on the same depth-level and , if not found, the pair found at the n+1 depth-level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_insertr2(
  inpt,
  algo_used = c(1:3),
  flagged_pair_v = c(")", "]"),
  corr_v = c("(", "["),
  flagged_conj_v = c("&amp;", "|"),
  method = c("(", ")")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt">inpt</code></td>
<td>
<p>is the input character representing an arbitrary condition, like ReGex for example, or information to a parser for example</p>
</td></tr>
<tr><td><code id="algo_used">algo_used</code></td>
<td>
<p>is a vector containing one or more of the 3 algorythms used. The first algorythm will simply put the pair of parenthesis at the condition surrounded and/or after a character flagged (in flagged_conj_v) as a conjunction. The second algorythm will put parenthesis at the condition that are located after other conditions that are surrounded by a pair. The third algorythm will put a pair at all the condition, it is very powerfull but takes a longer time. See examples and make experience to see which combination of algorythm(s) is the most efficient for your use case.</p>
</td></tr>
<tr><td><code id="flagged_pair_v">flagged_pair_v</code></td>
<td>
<p>is a vector containing all the first character of the pairs</p>
</td></tr>
<tr><td><code id="corr_v">corr_v</code></td>
<td>
<p>is a vector containing all the last character of the pairs</p>
</td></tr>
<tr><td><code id="flagged_conj_v">flagged_conj_v</code></td>
<td>
<p>is a vector containing all the conjunction character</p>
</td></tr>
<tr><td><code id="method">method</code></td>
<td>
<p>is length 2 vector containing as a first index, the first character of the pair inserted, and at the last index, the second and last character of the pair</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(pairs_insertr2(inpt = "([one]|two|twob)three(four)", algo_used = c(1), method = c("(", ")")))

[1] "([one]|(two)|(twob))three(four)"

print(pairs_insertr2(inpt = "([one]|two|twob)three(four)", algo_used = c(1), method = c("[", "]")))

[1] "([one]|[two]|[twob])three(four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2)))

[1] "(oneA|[one]|(two)|(twob))(three)(four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2), method = c("-", "#"),
                     flagged_pair_v = c(")", "]", "#"), corr_v = c("(", "[", "-")))

[1] "(oneA|[one]|-two#|-twob#)-three#(four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2, 3)))

[1] "((oneA)|[one]|(two)|(twob))(three)(four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(3), method = c("[", "]")))

[1] "([oneA]|[one]|[two]|[twob])[three](four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three((four))", algo_used = c(3)))

[1] "((oneA)|[one]|(two)|(twob))(three)((four))"

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: pairs_insertr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>pairs_insertr</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>pairs_insertr</h2>

<h3>Description</h3>

<p>Takes a character representing an arbitrary condition (like ReGeX for example) or an information (to a parser for example), vectors containing all the pair of pattern that potentially surrounds condition (flagged_pair_v and corr_v), and a vector containing all the conjuntion character, as input and returns the character with all or some of the condition surrounded by the pair characters. See examples. All the pair characters are inserted according to the closest pair they found priotizing those found next to the condition and on the same depth-level and , if not found, the pair found at the n+1 depth-level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_insertr(
  inpt,
  algo_used = c(1:3),
  flagged_pair_v = c(")", "]"),
  corr_v = c("(", "["),
  flagged_conj_v = c("&amp;", "|")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt">inpt</code></td>
<td>
<p>is the input character representing an arbitrary condition, like ReGex for example, or information to a parser for example</p>
</td></tr>
<tr><td><code id="algo_used">algo_used</code></td>
<td>
<p>is a vector containing one or more of the 3 algorythms used. The first algorythm will simply put the pair of parenthesis at the condition surrounded and/or after a character flagged (in flagged_conj_v) as a conjunction. The second algorythm will put parenthesis at the condition that are located after other conditions that are surrounded by a pair. The third algorythm will put a pair at all the condition, it is very powerfull but takes a longer time. See examples and make experience to see which combination of algorythm(s) is the most efficient for your use case.</p>
</td></tr>
<tr><td><code id="flagged_pair_v">flagged_pair_v</code></td>
<td>
<p>is a vector containing all the first character of the pairs</p>
</td></tr>
<tr><td><code id="corr_v">corr_v</code></td>
<td>
<p>is a vector containing all the last character of the pairs</p>
</td></tr>
<tr><td><code id="flagged_conj_v">flagged_conj_v</code></td>
<td>
<p>is a vector containing all the conjunction character</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(pairs_insertr(inpt = "([one]|two|twob)three(four)", algo_used = c(1)))

[1] "([one]|[two]|[twob])three(four)"

print(pairs_insertr(inpt = "(one|[two]|twob)three(four)", algo_used = c(2)))

[1] "(one|[two]|[twob])(three)(four)"

print(pairs_insertr(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2)))

[1] "(oneA|[one]|[two]|[twob])(three)(four)"

print(pairs_insertr(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2, 3)))

[1] "([oneA]|[one]|[two]|[twob])(three)(four)"

print(pairs_insertr(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(3)))

[1] "([oneA]|[one]|(two)|(twob))(three)(four)"

print(pairs_insertr(inpt = "(oneA|[one]|two|twob)three((four))", algo_used = c(3)))

[1] "([oneA]|[(one)]|(two)|(twob))(three)((four))"

</code></pre>

</main>

</div>
</body></html>
